#pragma version 10
intcblock 1 0 8 32
bytecblock 0x

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createCertificate(string,pay)uint64
*abi_route_createCertificate:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// mbrPayment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (mbrPayment) for createCertificate must be a pay transaction
	assert

	// ipfsHash: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createCertificate(string,pay)uint64
	callsub createCertificate
	itob
	concat
	log
	intc 0 // 1
	return

// createCertificate(ipfsHash: string, mbrPayment: PayTxn): AssetID
//
// This method mints the certificate ASA for the user and
// returns the ASA ID.
// @param ipfsHash The hash for the certificate.
// @param mbrPayment Payment for the minimum balance requirement for the
// box storage where a reference to the ASA would be persisted in.
// @returns The ID of the asset.
createCertificate:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/BlockTrempNFT.algo.ts:35
	// assert(!this.certificateBoxes(ipfsHash).exists)
	frame_dig -1 // ipfsHash: string
	box_len
	swap
	pop
	!
	assert

	// contracts/BlockTrempNFT.algo.ts:37
	// totalCost = MBR + COST_PER_BOX + (COST_PER_BYTE * (64 + 64))
	pushint 153700
	frame_bury 0 // totalCost: uint64

	// contracts/BlockTrempNFT.algo.ts:39
	// assert(mbrPayment.amount >= totalCost)
	frame_dig -2 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 0 // totalCost: uint64
	>=
	assert

	// contracts/BlockTrempNFT.algo.ts:40
	// assert(mbrPayment.receiver === this.app.address)
	frame_dig -2 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/BlockTrempNFT.algo.ts:41
	// assert(mbrPayment.sender === this.txn.sender)
	frame_dig -2 // mbrPayment: PayTxn
	gtxns Sender
	txn Sender
	==
	assert

	// contracts/BlockTrempNFT.algo.ts:44
	// ipfsUrl = 'ipfs://' + ipfsHash
	pushbytes 0x697066733a2f2f // "ipfs://"
	frame_dig -1 // ipfsHash: string
	concat
	frame_bury 1 // ipfsUrl: byte[]

	// contracts/BlockTrempNFT.algo.ts:46
	// assetID = sendAssetCreation({
	//       configAssetTotal: 1,
	//       configAssetDecimals: 0,
	//       configAssetName: 'Blocktremp Certificate',
	//       configAssetUnitName: 'BCERT',
	//       configAssetURL: ipfsUrl,
	//     })
	itxn_begin
	pushint 3 // acfg
	itxn_field TypeEnum

	// contracts/BlockTrempNFT.algo.ts:47
	// configAssetTotal: 1
	intc 0 // 1
	itxn_field ConfigAssetTotal

	// contracts/BlockTrempNFT.algo.ts:48
	// configAssetDecimals: 0
	intc 1 // 0
	itxn_field ConfigAssetDecimals

	// contracts/BlockTrempNFT.algo.ts:49
	// configAssetName: 'Blocktremp Certificate'
	pushbytes 0x426c6f636b7472656d70204365727469666963617465 // "Blocktremp Certificate"
	itxn_field ConfigAssetName

	// contracts/BlockTrempNFT.algo.ts:50
	// configAssetUnitName: 'BCERT'
	pushbytes 0x4243455254 // "BCERT"
	itxn_field ConfigAssetUnitName

	// contracts/BlockTrempNFT.algo.ts:51
	// configAssetURL: ipfsUrl
	frame_dig 1 // ipfsUrl: byte[]
	itxn_field ConfigAssetURL

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury 2 // assetID: uint64

	// contracts/BlockTrempNFT.algo.ts:54
	// metadata: Metadata = {
	//       asaId: assetID.id,
	//       address: this.txn.sender,
	//     }
	frame_dig 2 // assetID: uint64
	itob
	txn Sender
	concat
	frame_bury 3 // metadata: Metadata

	// contracts/BlockTrempNFT.algo.ts:59
	// this.certificateBoxes(ipfsHash).value = metadata
	frame_dig -1 // ipfsHash: string
	frame_dig 3 // metadata: Metadata
	box_put

	// contracts/BlockTrempNFT.algo.ts:61
	// return assetID;
	frame_dig 2 // assetID: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// claimCertificate(string)void
*abi_route_claimCertificate:
	// ipfsHash: string
	txna ApplicationArgs 1
	extract 2 0

	// execute claimCertificate(string)void
	callsub claimCertificate
	intc 0 // 1
	return

// claimCertificate(ipfsHash: string): void
claimCertificate:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/BlockTrempNFT.algo.ts:65
	// assert(this.certificateBoxes(ipfsHash).exists)
	frame_dig -1 // ipfsHash: string
	box_len
	swap
	pop
	assert

	// contracts/BlockTrempNFT.algo.ts:67
	// box = this.certificateBoxes(ipfsHash).value
	frame_dig -1 // ipfsHash: string
	frame_bury 0 // storage key//box

	// contracts/BlockTrempNFT.algo.ts:69
	// assert(this.txn.sender === box.address)
	txn Sender
	frame_dig -1 // ipfsHash: string
	intc 2 //  headOffset
	intc 3 // 32
	box_extract
	==
	assert

	// contracts/BlockTrempNFT.algo.ts:70
	// assert(this.txn.sender.isOptedInToAsset(AssetID.fromUint64(box.asaId)))
	txn Sender
	frame_dig -1 // ipfsHash: string
	intc 1 // 0
	intc 2 // 8
	box_extract
	btoi
	asset_holding_get AssetBalance
	swap
	pop
	assert

	// contracts/BlockTrempNFT.algo.ts:71
	// assert(this.app.address.assetBalance(AssetID.fromUint64(box.asaId)) === 1)
	global CurrentApplicationAddress
	frame_dig -1 // ipfsHash: string
	intc 1 // 0
	intc 2 // 8
	box_extract
	btoi
	asset_holding_get AssetBalance
	pop
	intc 0 // 1
	==
	assert

	// contracts/BlockTrempNFT.algo.ts:73
	// sendAssetTransfer({
	//       assetReceiver: box.address,
	//       assetAmount: 1,
	//       xferAsset: AssetID.fromUint64(box.asaId),
	//     })
	itxn_begin
	pushint 4 // axfer
	itxn_field TypeEnum

	// contracts/BlockTrempNFT.algo.ts:74
	// assetReceiver: box.address
	frame_dig -1 // ipfsHash: string
	intc 2 //  headOffset
	intc 3 // 32
	box_extract
	itxn_field AssetReceiver

	// contracts/BlockTrempNFT.algo.ts:75
	// assetAmount: 1
	intc 0 // 1
	itxn_field AssetAmount

	// contracts/BlockTrempNFT.algo.ts:76
	// xferAsset: AssetID.fromUint64(box.asaId)
	frame_dig -1 // ipfsHash: string
	intc 1 // 0
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x3dcd145d // method "createCertificate(string,pay)uint64"
	pushbytes 0xe66aaee6 // method "claimCertificate(string)void"
	txna ApplicationArgs 0
	match *abi_route_createCertificate *abi_route_claimCertificate

	// this contract does not implement the given ABI method for call NoOp
	err